---
title: "Seasonality and autocorrelation"
format: gfm
---

In Geoscience we often measure a variable though time. Just like in regression

We will follow the textbook's chapter 11.7 and use data on the trends in atmospheric carbon dioxide from the National Oceanic and Atmospheric Administration (NOAA, Fig.Â 11.9). In 1958, C.D. Keeling started monitoring $CO_2$ levels in the Mauna Loa Observatory on Hawaii. It was the first continuous monitoring programme and provided evidence for the rise of $CO_2$ concentration in the atmosphere. You can find more about it on the [curve's official website](https://keelingcurve.ucsd.edu/).

Exercise based on [T. Haslwanter's textbook materials](https://github.com/thomas-haslwanter/statsintro-python-2e/blob/master/ipynbs/11_timeSeries.ipynb).

# Code

```{python}
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
import ssl
```

The original dataset is provided in a format that is not easy for automatic machine reading (e.g. the column headers occupy different number of lines). So to read it in, you would need to make it machine-friendly, e.g. one row = one observation. We provide this cleaned dataset for you.

Read in the dataset:
```{python}
path = '../Data/monthly_in_situ_co2_mlo.csv'
df = pd.read_csv(path, sep=',')
```

Preview the dataset:
```{python}
df.head()
```

If we wanted to plot the values in time, we could currently do it either by month number, or by the year, but not both. You need to create an extra variable that will represent the time in a continuous manner. 

<details>
  <summary>Solution</summary>
```{python}
df['time'] = df['Year'].map(str) + '.' + df['Month'].map(str)
```

Visualize it:
```{python}
df.plot('time', 'CO2')
```

Here we use the function `seasonal_decompose` from `statsmodels` to separate the linear trend from the seasonal component. The measurements are taken every month so the period of seasonality is 12. We use the additive model because the amplitude of the seasonal component does not change with the level of the time series - see eq. 11.13 in the textbook. 

```{python}
result_add = seasonal_decompose(df['CO2'], model='additive', period=12, extrapolate_trend='freq')
```

Now we can plot the additive components and save the figure:
```{python}
result_add.plot()
pil_kwargs = {'quality': 90}
plt.savefig('TSA_decomposition.jpg', dpi=200, pil_kwargs=pil_kwargs)
plt.show()
```

The first three plots are easy to interpret but what is the last one, residuals? These are the deviations from the trend and seasonality. So these are "anomalies" which cannot be explained by the seasonality or the continuous trend.
```{python}
%matplotlib inline

plt.plot(result_add.resid, '-')
```

We can check if there is any autocorrelation in the residuals.
```{python}
plot_acf(result_add.resid)
plt.show()
```
Following the textbook, we find that:
> The systematic patterns in the autocorrelation function show that some > seasonal components are not constant and have been missed. The blue 
> shaded area indicates the 95%-confidence interval for the 
> autocorrelation coefficients.

```{python}
#| include: false
plot_pacf(result_add.resid)
plt.show()
```

## Fit an ARIMA model
```{python}
model = ARIMA(result_add.trend, order=(1,0,1))
model_fit = model.fit()
print(model_fit.summary())
```

```{python}
model = ARIMA(result_add.resid, order=(0,0,2))
model_fit = model.fit()
print(model_fit.summary())
```
