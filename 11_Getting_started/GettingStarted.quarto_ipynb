{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Getting started with data analysis\n",
        "\n",
        "# Background to this example\n",
        "\n",
        "Data comes in all sorts and forms within Earth sciences, from long term paleo records describing Oxygen levels in the atmosphere, timeseries of river discharge and spatio-temporal satellite images monitoring the vegetation. Within Earth Sciences we work with all these types of data to understand the past, present and future of the Earth system. Before we can work with these types of data we need to understand what we can and cannot do with the data, which conclusion we can and cannot draw.\n",
        "\n",
        "**In this practical we will start looking at different types of data and distributions of these data to get a better understanding of the different types of data and their distributions.**\n",
        "\n",
        "Let's start with using Python again by opening your Conda environment and then opening Spyder (for detailed instructions please look back at the first practical). We start by loading some of the stand libraries in this course. We use:\n",
        "\n",
        "-   Pandas (data management and data handling)\n",
        "\n",
        "-   Numpy (statistical analysis and data handling)\n",
        "\n",
        "-   Matplotlib (plotting)\n",
        "\n",
        "## Code\n",
        "\n",
        "``` python\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "import scipy.stats as stats\n",
        "```\n",
        "\n",
        "Now we are going to take a look at the first dataset which contains information about the amount of precipitation in the Netherlands.\n",
        "\n",
        "``` python\n",
        "precip = pd.read_csv(\"../Data/annualPrecipitation.csv\", index_col=0)\n",
        "```\n",
        "\n",
        "In this dataset you find the annual sum of precipitation in the last century. The data is now stored in the variable *precip.* You can explore the data by looking at the data within this variable with:\n",
        "\n",
        "``` python\n",
        "precip.head()\n",
        "```\n",
        "\n",
        "Alternatively you can explore the data with the variable explorer that you find within Spyder\n",
        "\n",
        "![By clicking on the variable you can now look at the values within the variable explorer](images/Screenshot%202024-06-21%20at%2015.45.17.png)\n",
        "\n",
        "![](images/Screenshot%202024-06-21%20at%2015.45.41.png)\n",
        "\n",
        "# Starting with Pandas data analysis\n",
        "\n",
        "Next we go and look at the data by visualizing the data. Within Pandas there are multiple opportunities to explore and visualize the data. There are lots of resources to help you with using Pandas and provide nice tips, trick and examples. For example you can use a **cheat sheet** to quickly remember and double check which functions to use (e.g. <https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf>). You can also find lots of good examples that use Pandas online for different types of data and types of analysis (<https://realpython.com/search?q=pandas>).\n",
        "\n",
        "## Normal distributions\n",
        "\n",
        "On of the first things we often do is test if data follows a Gaussian distribution and is thus normally distributed. This typically means that the sample we have obtained is the result of many random sample from a distribution. Common example are the height or weight of people, but it is also very common in many examples in the Earth sciences like air temperature.\n",
        "\n",
        "### Central limit theorem\n",
        "\n",
        "In research, to get a good idea of a population mean (\\$\\\\mu\\$), ideally you’d collect data from multiple random samples within the population. A **sampling distribution of the mean** is the distribution of the means of these different samples.\n",
        "\n",
        "The central limit theorem shows the following:\n",
        "\n",
        "-   Law of Large Numbers: As you increase sample size (or the number of samples), then the sample mean will approach the population mean.\n",
        "\n",
        "-   With multiple large samples, the sampling distribution of the mean is normally distributed, even if your original variable is not normally distributed.\n",
        "\n",
        "Parametric statistical tests typically assume that samples come from normally distributed populations, but the central limit theorem means that this assumption isn’t necessary to meet when you have a large enough sample.\n",
        "\n",
        "You can use parametric tests for large samples from populations with any kind of distribution as long as other important assumptions are met. It depends on the how heterogenous your data is but large samples in the earth sciences can range from 30 records to 10.000 of thousands of observations.\n",
        "\n",
        "### Testing if your data is normally distributed\n",
        "\n",
        "You can test if a dataset is normally distributed, either with a visual inspection of the data or a statistical test. Below we will explore both options.\n",
        "\n",
        "#### Question 1\n",
        "\n",
        "*Let's start with a visual inspection. A good way to start is to make a histogram of you data. Use the cheat sheet to explore which function to use to make a histogram of the precipitation data.*\n",
        "\n",
        "If you did it well you will find something like the image below, with the x-axis giving the different bins for annual precip ranging from roughly $400-1200~mm~y^{-1}$. The y-axis gives the number of years in each bin. You can see some of the distinct bell-shape that is to be expected from a normal distribution, but we can dive in a bit further.\n",
        "\n",
        "![](images/clipboard-2869557530.png){width=\"497\"}\n",
        "\n",
        "Another way is making a quantile-quantile plot of your data.\n",
        "\n",
        "``` python\n",
        "from statsmodels.graphics.gofplots import qqplot\n",
        "## First we need to sort the data for qqplot to work with it that's why we use precip.sort_values(\"Precip\") to sort the precipitation data from low to high. \"Precip is the name of the column in which we have the data (you can check this with precip.head()).\"\n",
        "qqplot(precip.sort_values(\"Precip\"), line='s')\n",
        "```\n",
        "\n",
        "![](images/clipboard-1121669530.png)\n",
        "\n",
        "In the figure you see the theoretical quantiles of the normal distribution and how the data (y-axis) relates to that. If the data is perfectly normally distributed it would fall on the red line.\n",
        "\n",
        "#### Question 2\n",
        "\n",
        "*Would you say the data is normally distributed based on this visual inspection of the data and why?*\n",
        "\n",
        "There is also a more quantitative way of checking if data is normally distributed, which is using a statistical normality test. One of the more commonly used test for this is the Shapiro Wilk Test. The [Shapiro-Wilk test](#0) evaluates a data sample and quantifies how likely it is that the data was drawn from a Gaussian distribution, named for Samuel Shapiro and Martin Wilk. In practice, the Shapiro-Wilk test is believed to be a reliable test of normality, although there is some suggestion that the test may be suitable for smaller samples of data, e.g. thousands of observations or fewer.\n",
        "\n",
        "#### Question 3\n",
        "\n",
        "*Try to implement the Shapiro Wilks test in Python on the precip dataset. You can use the function stats.shapiro, for which you find the manual here: <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.shapiro.html>.*\n",
        "\n",
        "If you did everything well you find that:\n",
        "\n",
        "``` python\n",
        "ShapiroResult(statistic=0.9821208214707591, pvalue=0.11845170228364588)\n",
        "```\n",
        "\n",
        "Since the p-value is above 0.05 we can assume that the data follows a normal distribution and is thus normally distributed.\n",
        "\n",
        "## Testing if two samples have the same mean\n",
        "\n",
        "Let's start by exploring some statistical properties of the rainfall data, starting with the mean annual precipitation and its standard deviation.\n",
        "\n",
        "``` python\n",
        "precip.mean()\n",
        "precip.std()\n",
        "```\n",
        "\n",
        "You can see that the Netherlands has a mean $\\pm$ standard deviation of around $802\\pm139~mm~y^{-1}$ precipitation. This amount varies year by year, and thus it can matter how many years of data you have to get the mean values. One of the important element is the amount of years of observations that are available. **We will now explore the impact of the length of the data record on the value we find for the average annual precipitation.**\n",
        "\n",
        "#### Question 4\n",
        "\n",
        "*Can you now make a piece of code that identifies how many year of data we have? There are two ways of exploring this, which can be using a function that checks the [length]{.underline} or the [shape]{.underline} of the Pandas array (you can use Google to help you).*\n",
        "\n",
        "If you did everything well you found that the total data record contains 118 years of data. For now we assume that the value of 800mm per year is the [true mean]{.underline} (µ) value of the annual precipitation in the Netherlands. Next we want to explore how many years of observations are needed to find the true value of annual precipitation. We will now use sub-samples of the full data record to see how many years we need. **Let's start by sub-sampling some of the data and computing and testing if the [sample mean]{.underline} accurately captures the [true mean]{.underline} (for which we now assume to be the +/- 800mm of the full data record).**\n",
        "\n",
        "``` python\n",
        "samplePrecip = precip.sample(n = 5, replace = False, random_state=1)\n",
        "```\n",
        "\n",
        "``` python\n",
        "      Precip\n",
        "Year        \n",
        "2000   932.4\n",
        "1960   928.7\n",
        "1965  1151.9\n",
        "2021   861.3\n",
        "1980   861.8\n",
        "```\n"
      ],
      "id": "7d5bed9d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## This is a testing block to see how this works :)\n",
        "precip.sample(n = 10, replace = False, random_state=1)"
      ],
      "id": "04498d25",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "*replace = False* indicates that every year should be only selected once and no years should be sampled twice. *random_state=1* is a way of guaranteeing that the same random numbers are selected and thus the same random years (this is mostly convenient if you want to reproduce your code, like for this practical). Now we would like to see if the average value that we obtain from the sample is a good representation of the total time series and thus represents the total [true mean]{.underline}.\n",
        "\n",
        "``` python\n",
        "samplePrecip.mean()\n",
        "```\n",
        "\n",
        "You will find that the mean precipitation for this sample is $947~mm~y^{-1}$, compared to the $802~mm~y^{-1}$ for the entire sample. You can see that these two values are different, but the question is if they are also statistically different. For this you will do an hypothesis test. The first step in constructing a hypothesis test is to be clear about what the null and alternative hypotheses are. This isn’t too hard to do. Our null hypothesis $H_{0}$, is that the true population mean $\\mu$ for annual precipitation is $802~mm~y^{-1}$; and our alternative hypothesis is that the population mean *isn’t* $802~mm~y^{-1}$. If we write this in mathematical notation, these hypotheses becomes\n",
        "\n",
        "$$\n",
        "H_{0}:\\mu_{1} = \\mu_{2}\\\\\n",
        "H_{1}:\\mu_{1}\\neq\\mu_{2}\n",
        "$$\n",
        "\n",
        "though to be honest this notation doesn’t add much to our understanding of the problem, it’s just a compact way of writing down what we’re trying to learn from the data. Before we can do this we need to make a couple of assumptions about the data:\n",
        "\n",
        "1.  The two samples are independent\n",
        "\n",
        "2.  The data is normally distributed\n",
        "\n",
        "3.  The data have a similar variance\n",
        "\n",
        "If you think these assumptions are valid we could use a t-test to test our hypothesis.\n",
        "\n",
        "#### Question 5\n",
        "\n",
        "*Do you think all of these criteria are met or do you see one that might be violated and if so why?*\n",
        "\n",
        "For now let's assume all those criteria are met and we can move on and perform an independent sample t-test. While you can also do this by hand following the appropriate equations in this course we like to focus on using and analysing the data rather than focussing on the exact mathematical equations. It is however important to understand when you can and can't use a certain test of approach. Luckily the independent sample t-test is available from the Scipy packages (a common package for statistical analysis). You can perform the test using:\n",
        "\n",
        "``` python\n",
        "import scipy.stats as stats\n",
        "stats.ttest_ind(precip, samplePrecip)\n",
        "```\n",
        "\n",
        "``` python\n",
        "TtestResult(statistic=array([-2.29273885]), pvalue=array([0.02359]), df=array([121.]))\n",
        "```\n",
        "\n",
        "Python will return three values to you, the first is the so-called t-statistic, the p-value which indicates the likelihood of $H_{0}$ to be true and df the degrees of freedom, the higher this value the more samples you typically used. In this situation you can see that the $H_{0}$ is rejected (p-value \\< 0.05) and thus we use the alternative hypothesis $H_{1}$. This means that with just 5 years of precipitation data we cannot accurately estimate the average annual precipitation over the Netherlands for the Bilt.\n",
        "\n",
        "#### Question 6\n",
        "\n",
        "*Find the number of years required to accurately represent the annual precipitation in the Bilt (*$\\mu_{1}$*).*\n",
        "\n",
        "# Looking for trends in your data\n",
        "\n",
        "With climate change meteorological variables are likely to change, we know that temperatures are increasing but what about precipitation. We could test this by looking splitting our long timeseries into multiple parts and checking if the mean annual precipitation is changing.\n",
        "\n",
        "#### Question 7\n",
        "\n",
        "*Make a timeseries plot of the data by using your cheat sheet and the .plot function.*\n",
        "\n",
        "![](images/clipboard-3761568892.png)\n",
        "\n",
        "If all went well you find the plot above. By looking at the data there are no clear trends in the data. We can also do a more quantitative approach using techniques that you have used before in this assignment.\n",
        "\n",
        "Make two sub-sample of the data one containing the first 30 years of the data and one containing the last 30 years of the data. You have two ways of doing so (look at you cheat sheet for Pandas). The first one is to use the .head() and .tail() functions.\n",
        "\n",
        "``` python\n",
        "firstYearsPrecip = precip.head(30)\n",
        "lastYearsPrecip = precip.tail(30)\n",
        "```\n",
        "\n",
        "There is also another option using the .iloc() function:\n",
        "\n",
        "``` python\n",
        "firstYearsPrecip = precip.iloc[:30]\n",
        "lastYearsPrecip = precip.iloc[-30:]\n",
        "```\n",
        "\n",
        "If you want to select specific year you can use:\n",
        "\n",
        "``` python\n",
        "firstYearsPrecip = precip.loc[\"1906\":\"1935\"]\n",
        "lastYearsPrecip = precip.loc[\"1994\":\"2023\"]\n",
        "```\n",
        "\n",
        "The advantage of this method is that you can specify years you want to select. Also if they are not situated at the start of end of the timeseries. You can do the same with the *iloc* function, but in that case you do need to identify the exact row numbers of interest.\n",
        "\n",
        "#### Question 8\n",
        "\n",
        "*Make a small script that selects the first and last 30 years of data and then tests if the mean of the two dataset are different or not. In other words:*\n",
        "\n",
        "$$\n",
        "H_{0}:\\mu_{1906-1935} = \\mu_{1994-2023}\\\\\n",
        "H_{1}:\\mu_{1906-1935}\\neq\\mu_{1994-2023}\n",
        "$$\n",
        "\n",
        "# Investigating a new dataset\n",
        "\n",
        "Now it is time to use the skills you have just obtained on a new dataset \"*dailyTemperature.csv*\".\n",
        "\n",
        "#### **Please explore the following things**\n",
        "\n",
        "1.  Plot the data as a timeseries\n",
        "\n",
        "2.  Is this dataset normally distributed\n",
        "\n",
        "    1.  Using a graphical method\n",
        "\n",
        "    2.  Using the Shapiro test\n",
        "\n",
        "3.  Explore graphically if there are trends and try to quantify the trends by comparing the period 1901-1930 to 1990-2019.\n",
        "\n",
        "4.  Test is the the year 2021 was significantly warmer than 2022\n",
        "\n",
        "#### Findings\n",
        "\n",
        "If all went well you find that the data is not normally distributed, that there is a deviation from the normal distribution especially in the higher temperature values as can be seen from the plot below.\n",
        "\n",
        "![](images/clipboard-343210100.png)\n",
        "\n",
        "If you explored the data you will also see that there are strong trends in the temperature data as can be expected with climate change.\n",
        "\n",
        "# Processing your timeseries data\n",
        "\n",
        "There are some tricks that can help you to better work with your data. You might have seen that the temperature data you got was not with an annual timestep but was actually the daily data from the Bilt weather station. There are tricks to easily aggregate your time data to different timescales. For example you can compute the annual mean temperature with:\n",
        "\n",
        "``` python\n",
        "annualTas = Tas.resample(\"YE\").mean()\n",
        "annualTas\n",
        "\n",
        "                  Tas\n",
        "Date                 \n",
        "1901-12-31   8.783562\n",
        "1902-12-31   8.245205\n",
        "1903-12-31   9.166575\n",
        "1904-12-31   8.933607\n",
        "1905-12-31   8.713699\n",
        "              ...\n",
        "2020-12-31  11.688251\n",
        "2021-12-31  10.481096\n",
        "2022-12-31  11.572603\n",
        "2023-12-31  11.790959\n",
        "2024-12-31  10.002907\n",
        "\n",
        "[124 rows x 1 columns]\n",
        "```\n",
        "\n",
        "You can also find the annual minimum and maximum temperatures in a fairly similar manner\n",
        "\n",
        "``` python\n",
        "annualMinTas = Tas.resample(\"YE\").min()\n",
        "annualMaxTas = Tas.resample(\"YE\").max()\n",
        "```\n",
        "\n",
        "#### Question 9\n",
        "\n",
        "*Explore if the annual mean, min and max temperature are normally distributed.*\n",
        "\n",
        "#### Question 10\n",
        "\n",
        "*Could you explain why some of these new annual data are normally distributed and the daily timeseries is not. If it helps try to plot the daily data for the year 2022 using the [loc]{.underline} and [plot]{.underline} functions*"
      ],
      "id": "ba4dc156"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3",
      "path": "/usr/local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}